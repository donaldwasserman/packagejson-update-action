const core = require('@actions/core');
const fs = require('fs');
const { GitHub } = require('@actions/github');

async function run() {
  const path = core.getInput('path'),
    token = core.getInput('token'),
    usePr = core.getInput('use_pullrequest'),
    defaultBranch = core.getInput('default_branch'),
    ownerRepo = process.env.GITHUB_REPOSITORY,
    eventPath = process.env.GITHUB_EVENT_PATH,
    eventName = process.env.GITHUB_EVENT_NAME;

  // Error checking
  if (!token) {
    core.error('You must provide a `token` argument. See documentation.');
    return;
  }

  if (!path) {
    core.error('You must provide a valid path');
  }

  const octokit = new GitHub(token);
  let sha, package;

  let { tag, releaseBranch } = getReleaseData(eventPath);
  let branch = defaultBranch || releaseBranch;

  try {
    let { data } = await octokit.repos.getContents({
      owner,
      repo,
      path
    });

    if (data.type !== 'file') {
      core.error(`Specified 'path' parameter ${path} is not a file`);
    }
    sha = data.sha;

    let packageBuff = Buffer.from(data.content, 'base64');
    package = JSON.parse(packageBuff.toString('utf8'));
  } catch (e) {
    core.error(`Cannot find specified package.json at ${path}: ${e}`);
  }

  let prBranch = core.getInput('branch_name') || `package.json-${tag}`;

  tag = tag.replace(/\d|\./g, '');
  package.version = tag;
  let newBuff = Buffer.from(JSON.stringify(package));

  let options = {
    owner,
    repo,
    path,
    sha,
    message: 'updated package.json via Next Release action',
    content: newBuff.toString('base64')
  };

  if (usePr) {
    let refSha;
    try {
      let { data } = await octokit.git.getRef({
        owner,
        repo,
        ref: `heads/${branch}`
      });

      refSha = data.object.sha;
    } catch (e) {
      core.error(`Error creating changelog PR ${e}`);
      return;
    }

    try {
      await octokit.git.createRef({
        owner,
        repo,
        sha: refSha,
        ref: `refs/heads/${prBranch}`
      });
      options.branch = prBranch;
    } catch (e) {
      core.error(`Failed creating changelog PR: ${e}`);
      return;
    }
  }

  try {
    await octokit.repos.createOrUpdateFile(options);
  } catch (e) {
    core.error(`Failed updating Changelog: ${e}`);
    return;
  }

  try {
    await octokit.repos.createOrUpdateFile(options);
  } catch (e) {
    core.error(`Failed updating package.json ${e}`);
    return;
  }

  if (usePr) {
    try {
      await octokit.pulls.create({
        owner,
        repo,
        head: prBranch,
        base: branch,
        title: `Update ${path}`,
        maintainer_can_modify: true,
        body: 'Automatically generated by Next Release Changelog Action'
      });
    } catch (e) {
      core.error(`Error creating pull request with updated pacakge.json ${e}`);
      return;
    }
  }
}

function getReleaseData(eventPath) {
  const event = JSON.parse(fs.readFileSync(eventPath, 'utf8'));

  let {
    html_url: url,
    tag_name: tag,
    name,
    body,
    target_commitish: releaseBranch
  } = event.release;

  return { url, tag, name, body, releaseBranch };
}

run();
